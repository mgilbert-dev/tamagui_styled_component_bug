---
title: Write once, feels native
description: An optimizing compiler for React.
---

<IntroParagraph>
  If developing a web + mobile app today and using React Native, you've made this trade-off:
</IntroParagraph>

<YStack maw={650} als="center">
  ![The Frontend Trilemma: Choose two of DX, UX, and multi-platform (or run out of
  time).](/trilemma.svg)
</YStack>

The three intersecting three parts are your choices of can be framed as:

<Table heading="Choose your path:">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>1</TableCell>
    <TableCell>2</TableCell>
    <TableCell>3</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal</TableCell>
    <TableCell>Lean</TableCell>
    <TableCell>Big-Budget</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>\> 70%</TableCell>
    <TableCell>-</TableCell>
    <TableCell>\< 30%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
    <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
  </TableCol>
</Table>

The middle of the Venn diagram could be titled "write once, feels native" - aspirationally.

Many teams choose shipping fast over native feel, for a diverse set of rational reasons. Tamagui looks at it as a two sided problem. The first half, components that adapt to native controls, is something that React Native developers have been chipping away at over time.

But a huge blocker is just that React Native apps .

The Tamagui compiler does build-time optimization, including:

- Static `styled` factory extracts to atomic CSS.
- Inline styles extracted with partial evaluation and inlining.
- Tree-flattening by turning `styled` components into `div` or `View` when possible.
- Logically parses hooks for `useMedia` and `useTheme` into media queries and CSS variables.

It turns this:

##### Input

```tsx
import { Text, YStack } from '@tamagui/core'
import { brandColor } from './constants'

const App = (props) => (
  <YStack
    padding={props.big ? '$5' : '$3'}
    {...(props.colored && {
      backgroundColor: brandColor,
    })}
  >
    <Text
      color="green"
      $large={{
        color: 'yellow',
        $hover: {
          color: 'green',
        },
      }}
    >
      Lorem ipsum dolor.
    </Text>
  </YStack>
)
```

Intos something like this:

```tsx
import { YStack, concatClassName } from 'tamagui'

const App = (props) => (
  <div
    className={concatClassName(
      _cn + (props.big ? _cn2 : _cn3) + (' ' + (props.colored ? _cn4 : ' '))
    )}
  >
    <p className={_cn5}>Lorem ipsum dolor.</p>
  </div>
)

const _cn5 = ' _c-scmqyp _d-1471scf _ff-xeweqh _fs-7uzi8p _lh-1l6ykvy'
const _cn4 = '  _bc-1542mo4'
const _cn3 = ' _pb_-12bic3x _pl_-7ztw5e _pr-g6vdx7 _pt-1vq430g'
const _cn2 = ' _pb-z3qxl0 _pl-14km6ah _pr-1qpq1qc _pt-1medp4i'
const _cn = ' _bc-abc123 _d-6koalj _fd-eqz5dr _fls-1q142lx '
```

Along with CSS (which you can see, alongside more examples see [on the homepage](/)).

It uses tree flattening (turning the `Text` into `p`) which helps render performance above pure gains from CSS compilation. In a small benchmark just rendering a single view with logically changing "variants," you'll see large increases:

<YStack my="$2">
  <BenchmarkChartWeb />
</YStack>

Across a few apps, we've seen 30-50% of components typically flatten, with a higher percent achievable just by being aware of how the flattening de-optimizes (adding the `// debug` comment to the top of the file will show a fuller output).

Meanwhile, on Native, because we can't optimize to anything beyond vanilla React Native code, the gains are less. Still, the results are impressive given you are now getting a huge amount of features and nice syntax that normally would eat up a lot of performance, and the net result is basically the same as hand-optimized React Native:

<YStack my="$2">
  <BenchmarkChartNative />
</YStack>

You can see [the full Benchmarks with explanations here](/docs/intro/benchmarks).

More detailed docs on how the compiler, optimizer and partial evaluation works will come in a follow-up article.

Compilers can dramatically improve code sharing without sacrificing performance, and improve adaptation to platforms.

<Table>
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>4</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal + Compiler</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>~60-90%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
</Table>

---

Give Tamagui a try with `npm create tamagui-app`.
