---
title: The Frontend Trilemma
description: Attempting to 2x the performance for apps written in ~½ the code.
---

<IntroParagraph>
  If you're developing a cross-platform app, you've made an implicit decision. This decision can be
  thought of as a **frontend development trilemma**, illustrated as a choose-two-of-three:
</IntroParagraph>

<YStack w="100%" mih={500} my="$4" als="center" $gtMd={{ scale: 1.5, my: 100 }}>
  <Image
    title="The Frontend Trilemma: Choose two of DX, UX, and multi-platform"
    src="/trilemma.svg"
    size="hero"
    height={380}
    width={380}
    resizeMode="contain"
  />
</YStack>

React Native recommends writing things twice generally for the best UX - as is made very clear in the `<title>` of the homepage itself: "[learn once, write anywhere](https://reactnative.dev/)" as opposed to "write once, runs everywhere". This pays off today with native-feeling and performing apps, but still saving a lot of development time.

But we can imagine that center, a sort of platonic ideal of <strong>"write once, runs great everywhere"</strong>, as we're far from perfect today.

It would involve a few things:

- Some Rails-for-React framework with unified routing, generators, or whatever "all the batteries" means.
- A huge UI kit that outputs to beautiful platform primitives confidently with flexible APIs.
- An optimizing compiler that removes inline styles and outputs to native primitives.

This document goes over the last one. The second one the Tamagui UI kit attempting to solve, but that will take a lot of time. And the first sounds hard.

We'll argue that a "bump" much like the one with React Native Web made here, is possible with an optimizing compiler by reducing JS bundle size by a large %, and increasing render performance similarly:

<YStack w="100%" mih={220} my="$4" als="center" $gtMd={{ scale: 1.5, my: 100 }}>
  <Image
    title="How possible it is to share more code: a lot more with React Native, and again with React Native Web"
    src="/code-sharing.svg"
    size="hero"
    height={220}
    width={380}
    resizeMode="contain"
  />
</YStack>

The Tamagui Compiler optimizes apps in four different ways beyond basic CSS extraction with partial evaluation, static hoisting, code elimination, and tree-flattening.

You can [kkip this next section to get technical details without backstory](#how-tamagui-helps).

<Table>
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>1</TableCell>
    <TableCell>2</TableCell>
    <TableCell>3</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal</TableCell>
    <TableCell>Lean</TableCell>
    <TableCell>Big-Budget</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>\> 70%</TableCell>
    <TableCell>-</TableCell>
    <TableCell>\< 30%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
    <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
  </TableCol>
</Table>

Universal apps (those that you "write once" and they "runs everywhere") make sense today for many cases, whether side-projecting, SEO-insensitive, enterprise-only, shipping faster, experimenting more, pre-product-market fit, or just generally a simple app. Twitter and Tinder both do this to a larger degree.

But today at best we use hooks for media queries and themes, causing big render costs on the web where both are more performance sensitive. Combined with the CSS-in-JS approach of React Native Web and even low-complexity pages easily drop from 100% Lighthouse to half or worse.

For now, this means your media queries, interactive styles, and all theme, animation, and dynamic styles end up running on your main thread, oftentimes re-reconciling a large percents of the React tree in sensitive areas to UX.

### How Tamagui Helps

`@tamagui/static` is an optimizing compiler for React Native with four main features:

<YStack py="$4">
  <Features
    size="$5"
    items={[
      `Extracts all types of styling syntax into atomic CSS.`,
      `Removes a high % of inline styles with partial evaluation and hoisting.`,
      `Reduces tree depth, flattening expensive styled components into div or View.`,
      `Evaluates useMedia and useTheme hooks, turning logical expressions into media queries and CSS variables.`,
    ]}
  />
</YStack>

The output is smaller bundles, better runtime performance, and many more native primitives used on the web.

Here's what it does, in code:

<TamaguiExamplesCode />

See [more examples on the homepage](/).

Notice that the compiler turned the `Text` into a `p`, and the `YStack` into a `div` (on native, this would be `Text` and `View`). This is known as tree-flattening, and for both web and native it yields very nice improvements to render performance.

This is a typical performance improvement, where much of the gains come from flattening:

<YStack my="$2">
  <BenchmarkChartWeb />
</YStack>

Across a few apps, we've seen 30-50% of components typically flatten, with a higher percent achievable just by being aware of how the flattening optimizes (adding the `// debug` comment to the top of the file will show a fuller output).

Meanwhile, on Native, because we can't optimize to anything beyond vanilla React Native code, the gains are less. Still, the results are impressive given you now have performance within 5% of hand-optimizing React Native code, except you get a whole suite of features for free.

<YStack my="$2">
  <BenchmarkChartNative />
</YStack>

You can see [more Benchmarks with explanations here](/docs/intro/benchmarks).

The compiler itself deserves more detail, which we'll expand on in the blog. For now, this serves as a decent introduction.

Compilers can dramatically improve code sharing without the typical sacrifice of performance. They don't solve every problem of universal apps, but by making responsive styling, themes and interactive styles all perform at native levels, they unlock sharing a much larger percentage of the components located in the middle to bottom of the render tree in apps.

It gives us a new choice:

<Table my="$8">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>4</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal + Compiler</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>~60-90%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
</Table>

Give Tamagui a try with `npm create tamagui-app`.
