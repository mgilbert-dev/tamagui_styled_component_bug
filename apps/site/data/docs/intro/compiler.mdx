---
title: React, Faster
description: Tamagui's optimizing compiler for React nets 30-to-1,000% performance, in nearly ½ the code.
---

<IntroParagraph>
  If you are developing a web and mobile app using React Native (or really any platform) today,
  you've already made a decision. This decision can be thought of as a sort of **frontend
  development trilemma**, illustrated as a choose-two-of-three:
</IntroParagraph>

<YStack maw={650} als="center">
  ![The Frontend Trilemma: Choose two of DX, UX, and multi-platform (or run out of
  time).](/trilemma.svg)
</YStack>

The center of this trilemma could be titled, "Write once, feels native." As of today it's nearly impossible (and at the limit perhaps not even desirable), but not for good reason. This document isn't arguing every reason why, but will focus on React Native, and how we can realistically gain 20-50% more code share without sacrificing any UX compared to writing separate apps targeted to each platform.

The Tamagui Compiler does just this by optimizing apps in four different ways. To skip to the details, [head to the next section](#how-tamagui-helps).

### Why Universal

React Native enables quite a bit more code-sharing than ever before while still rendering to native primitives. But it recommends writing things twice generally for the best UX - as is made very clear in the `<title>` of the homepage itself: "[learn once, write anywhere](https://reactnative.dev/)" as opposed to "write once, runs everywhere."

This is a smart strategy, and it can pay off in more native-feeling and performing apps.

Still, the reality is that many companies large and small make _rational_ decisions to share code to some degree, up to and including nearly all of the visual code besides maybe a few high level views. In React, this is generally done using the excellent [React Native Web](https://necolas.github.io/react-native-web/).

The reason it simple - shipping, and iterating, faster. There's a ton of reasons why this may be crucial - you're pre-product-market fit, or have an app with a large surface area. Or you simply are low on budget, time or both. Even bigger companies choose this strategy. Twitter, or Tinder are examples of this. It comes down to whether they can afford to sacrifice SEO, initial load times, and can afford to ship less complex interfaces.

The reasons for wanting to write less code are fairly inherent. It's just the outcome we often don't like: the sacrifice of peformance and native-specific UI elements.

Those three intersecting parts of the diagram at the top could be framed as a choice between "Universal", "Lean", or "Big-Budget" app-building.

<Table heading="Choose your path:">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>1</TableCell>
    <TableCell>2</TableCell>
    <TableCell>3</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal</TableCell>
    <TableCell>Lean</TableCell>
    <TableCell>Big-Budget</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>\> 70%</TableCell>
    <TableCell>-</TableCell>
    <TableCell>\< 30%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
    <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
  </TableCol>
</Table>

At best, without sacrificing performance, a React Native app today can share much of its state and utilities (like hooks), as well as _some amount of visual components_. But it's true that the more code you share, the lower the performance your app will have, sometimes in incredible critical areas like media queries, or animations.

This is more true on the web, where the CSS-in-JS approach of React Native Web leads to very large bundle-sizes and hugely reduced performance in critical areas like responsive styles (mostly due to the `StyleSheet` API not supporting that, and other web-optimized features).

This means your media queries run, your interactive styles like hover or click effects, and any and all themes, animations, or dynamic styles end up causing expensive re-renders (oftentimes the entire tree) in sensitive areas.

### How Tamagui Helps

The Tamagui compiler makes writing Universal Apps much faster - especially on the web - through its optimizing compiler. It reduces bundle size, improves runtime performance, and outputs code that targets native primitives instead of running in JS (on the web, that's CSS media queries, CSS variables, and CSS pseudo styles).

It optimizes:

- Any usage of the `styled` factory function into atomic CSS.
- Most inline styles using both `partial evaluation` and `hoisting`.
- Tree depth, by turning your custom components into `div` or `View` when possible.
- The included hooks `useMedia` and `useTheme`, turning even logical conditionals into static media queries or CSS variables.

It can turn something like this:

##### Input

```tsx
import { Text, YStack } from '@tamagui/core'

import { brandColor } from './constants'

const App = (props) => (
  <YStack
    padding={props.big ? '$5' : '$3'}
    {...(props.colored && {
      backgroundColor: brandColor,
    })}
  >
    <Text
      color="green"
      $large={{
        color: 'yellow',
        $hover: {
          color: 'green',
        },
      }}
    >
      Lorem ipsum dolor.
    </Text>
  </YStack>
)
```

Into this:

```tsx
import { YStack, concatClassName } from 'tamagui'

const App = (props) => (
  <div
    className={concatClassName(
      _cn + (props.big ? _cn2 : _cn3) + (' ' + (props.colored ? _cn4 : ' '))
    )}
  >
    <p className={_cn5}>Lorem ipsum dolor.</p>
  </div>
)

const _cn5 = ' _c-scmqyp _d-1471scf _ff-xeweqh _fs-7uzi8p _lh-1l6ykvy'
const _cn4 = '  _bc-1542mo4'
const _cn3 = ' _pb_-12bic3x _pl_-7ztw5e _pr-g6vdx7 _pt-1vq430g'
const _cn2 = ' _pb-z3qxl0 _pl-14km6ah _pr-1qpq1qc _pt-1medp4i'
const _cn = ' _bc-abc123 _d-6koalj _fd-eqz5dr _fls-1q142lx '
```

Along with a CSS (of which you can see alongside many more examples see [on the homepage](/)).

Notice that the compiler turned the `Text` into a `p`, and the `YStack` into a `div`. This is known as tree-flattening, and for both web and native it yields very nice improvements to render performance.

This is a typical performance improvement, where much of the gains come from flattening:

<YStack my="$2">
  <BenchmarkChartWeb />
</YStack>

Across a few apps, we've seen 30-50% of components typically flatten, with a higher percent achievable just by being aware of how the flattening de-optimizes (adding the `// debug` comment to the top of the file will show a fuller output).

Meanwhile, on Native, because we can't optimize to anything beyond vanilla React Native code, the gains are less. Still, the results are impressive given you now have performance within 5% of hand-optimizing React Native code, except you get a whole suite of features for free.

<YStack my="$2">
  <BenchmarkChartNative />
</YStack>

You can see [more Benchmarks with explanations here](/docs/intro/benchmarks).

The compiler itself deserves more detail, which we'll expand on in the blog. For now, this serves as a decent introduction.

Compilers can dramatically improve code sharing without the typical sacrifice of performance. They don't solve every problem of universal apps, but by making responsive styling, themes and interactive styles all perform at native levels, they unlock sharing a much larger percentage of the "middle to leaf" components in apps.

It gives us a new choice:

<Table my="$8">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>4</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal + Compiler</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>~60-90%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
</Table>

Give Tamagui a try with `npm create tamagui-app`.
