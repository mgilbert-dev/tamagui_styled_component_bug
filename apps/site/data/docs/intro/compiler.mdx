---
title: The Frontend Trilemma
description: About ½ the code, up to twice the performance.
---

<IntroParagraph>
  If you are developing a cross-platform app, you've made an implicit decision. This decision can be
  thought of as a **frontend development trilemma**, illustrated as a choose-two-of-three:
</IntroParagraph>

<YStack w="100%" mih={500} my="$4" als="center" $gtMd={{ scale: 1.5, my: 100 }}>
  <Image
    title="The Frontend Trilemma: Choose two of DX, UX, and multi-platform"
    src="/trilemma.svg"
    size="hero"
    height={380}
    width={380}
    resizeMode="contain"
  />
</YStack>

The center would be something like "write once, feels native." As of today it's basically impossible, and at the limit maybe not even desirable.

This document focuses just on **how we can realistically gain 20-50% more code share on React Native without sacrificing, and oftentimes improving, performance** (and UX) compared to writing separate apps targeted to each platform.

The Tamagui Compiler does this by optimizing apps in four different ways beyond basic CSS extraction, including partial evaluation, static hoisting and tree-flattening. For a bit more on that, you can skip the Why and [go to the next section](#how-tamagui-helps).

### Why Universal

React Native enables quite a bit more code-sharing than ever before while still rendering to native primitives. But it recommends writing things twice generally for the best UX - as is made very clear in the `<title>` of the homepage itself: "[learn once, write anywhere](https://reactnative.dev/)" as opposed to "write once, runs everywhere."

This is a smart strategy, and it can pay off in more native-feeling and performing apps.

Still, the reality is that many companies large and small make _rational_ decisions to share code to some degree, up to and including nearly all of the visual code besides maybe a few high level views. In React, this is generally done using the excellent [React Native Web](https://necolas.github.io/react-native-web/).

Pre product-market fit, for most types of apps it makes sense. Any app with a large surface area of features. Or any app where you want to experiment often and cheaply. Often the reason is as simple as budget, or time.

But it's common for bigger companies to do this too to a larger degree, Twitter and Tinder both do to a significant degree. Usually though this makes sense on apps that can sacrifice SEO, load time, and complex interfaces. The reasons for wanting to write less code are fairly inherent. It's just the outcome we often don't like: the sacrifice of peformance and native feel.

We can rephrase the diagram above as follows:

<Table heading="Choose your path:">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>1</TableCell>
    <TableCell>2</TableCell>
    <TableCell>3</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal</TableCell>
    <TableCell>Lean</TableCell>
    <TableCell>Big-Budget</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>\> 70%</TableCell>
    <TableCell>-</TableCell>
    <TableCell>\< 30%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
    <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
  </TableCol>
</Table>

At best, without sacrificing performance, a React Native app today can share much of its state and utilities (like hooks), as well as _some amount of visual components_. But the more code it shares, the more performance suffers. This is more true on the web, where the CSS-in-JS approach of React Native Web leads to large bundle-sizes and largely reduced performance in critical areas like responsive styles. This is mostly due to limitations in the `StyleSheet` API, some of which have proposals to fix.

For now, this means your media queries, interactive styles, and all theme, animation, and dynamic styles end up running on your main thread, oftentimes re-reconciling a large percents of the React tree, and causing laggy behavior in areas that most contribute to UX.

### How Tamagui Helps

The Tamagui compiler makes writing Universal Apps much faster - especially on the web - through its optimizing compiler. It reduces bundle size, improves runtime performance, and outputs code that targets native primitives instead of running in JS (on the web, that's CSS media queries, CSS variables, and CSS pseudo styles).

It optimizes:

- Any usage of the `styled` factory function into atomic CSS.
- Most inline styles using both `partial evaluation` and `hoisting`.
- Tree depth, by turning your custom components into `div` or `View` when possible.
- The included hooks `useMedia` and `useTheme`, turning even logical conditionals into static media queries or CSS variables.

A short demo:

<TamaguiExamplesCode />

See [more examples on the homepage](/).

Notice that the compiler turned the `Text` into a `p`, and the `YStack` into a `div` (on native, this would be `Text` and `View`). This is known as tree-flattening, and for both web and native it yields very nice improvements to render performance.

This is a typical performance improvement, where much of the gains come from flattening:

<YStack my="$2">
  <BenchmarkChartWeb />
</YStack>

Across a few apps, we've seen 30-50% of components typically flatten, with a higher percent achievable just by being aware of how the flattening optimizes (adding the `// debug` comment to the top of the file will show a fuller output).

Meanwhile, on Native, because we can't optimize to anything beyond vanilla React Native code, the gains are less. Still, the results are impressive given you now have performance within 5% of hand-optimizing React Native code, except you get a whole suite of features for free.

<YStack my="$2">
  <BenchmarkChartNative />
</YStack>

You can see [more Benchmarks with explanations here](/docs/intro/benchmarks).

The compiler itself deserves more detail, which we'll expand on in the blog. For now, this serves as a decent introduction.

Compilers can dramatically improve code sharing without the typical sacrifice of performance. They don't solve every problem of universal apps, but by making responsive styling, themes and interactive styles all perform at native levels, they unlock sharing a much larger percentage of the components located in the middle to bottom of the render tree in apps.

It gives us a new choice:

<Table my="$8">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>4</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal + Compiler</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>~60-90%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
</Table>

Give Tamagui a try with `npm create tamagui-app`.
