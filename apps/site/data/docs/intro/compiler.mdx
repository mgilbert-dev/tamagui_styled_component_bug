---
title: The Frontend Trilemma
description: Can we write ½ the code for 2x performance? Probably.
---

<IntroParagraph>
  If you're developing a cross-platform app, you've made an implicit decision. This decision can be
  thought of as a **frontend development trilemma**, illustrated as a choose-two-of-three:
</IntroParagraph>

<YStack w="100%" mih={500} my="$4" als="center" $gtMd={{ scale: 1.5, my: 100 }}>
  <Image
    title="The Frontend Trilemma: Choose two of DX, UX, and multi-platform"
    src="/trilemma.svg"
    size="hero"
    height={380}
    width={380}
    resizeMode="contain"
  />
</YStack>

Let's call the center "write once, feels native." The **feels native** part is important because it's mostly impossible today (and at the limit, likely not even desirable).

The reasons for that are many, but a primary one is simply that you lose optimizations that'd normally be easy by targeting platforms individually. In this document, we introduce **a realistic 20-50% extra code-sharing on React Native + Web, without sacrificing that performance** (oftentimes even improving it).

The Tamagui Compiler optimizes apps in four different ways beyond basic CSS extraction with partial evaluation, static hoisting, code elimination, and tree-flattening.

You can [skip the backstory to get straight to technical details](#how-tamagui-helps).

### Why Universal

React Native enables quite a bit more code-sharing than ever before while still rendering to native primitives. But it recommends writing things twice generally for the best UX - as is made very clear in the `<title>` of the homepage itself: "[learn once, write anywhere](https://reactnative.dev/)" as opposed to "write once, runs everywhere."

This is a smart strategy, and it can pay off in more native-feeling and performing apps.

Still, the reality is that many companies large and small make _rational_ decisions to share code to some degree, up to and including nearly all of the visual code besides maybe a few high level views. In React, this is generally done using the excellent [React Native Web](https://necolas.github.io/react-native-web/).

Pre product-market fit, for most types of apps it makes sense. Any app with a large surface area of features. Or any app where you want to experiment often and cheaply. Often the reason is as simple as budget, or time. It's not uncommon for bigger companies to share nearly all their code, too. To a significant degree, Twitter and Tinder both do this, but it only makes sense on apps like those that can sacrifice SEO, load time, and any complex interface.

So that's where we are. Here's a very back-of-napkit chart of the % of code a team could share fully between Native and Web, using React Native, without sacrificing performance today:

<YStack w="100%" mih={220} my="$4" als="center" $gtMd={{ scale: 1.5, my: 100 }}>
  <Image
    title="How possible it is to share more code: a lot more with React Native, and again with React Native Web"
    src="/code-sharing.svg"
    size="hero"
    height={220}
    width={380}
    resizeMode="contain"
  />
</YStack>

Don't sweat the details too much - and label the Y how you want, a decent estimate would be 0-100%, but depending on how picky you are, it could swing to something like 0-50%.

Our original trilemma is maybe easier seen as a "choose your path" of three options:

<Table>
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>1</TableCell>
    <TableCell>2</TableCell>
    <TableCell>3</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal</TableCell>
    <TableCell>Lean</TableCell>
    <TableCell>Big-Budget</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>\> 70%</TableCell>
    <TableCell>-</TableCell>
    <TableCell>\< 30%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>❌</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
    <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>✅</TableCell>
    <TableCell>❌</TableCell>
  </TableCol>
</Table>

At best, without sacrificing performance, a React Native app today can share much of its state and utilities (like hooks), as well as _some amount of visual components_. But the more code it shares, the more performance suffers. This is more true on the web, where the CSS-in-JS approach of React Native Web leads to large bundle-sizes and largely reduced performance in critical areas like responsive styles. This is mostly due to limitations in the `StyleSheet` API.

For now, this means your media queries, interactive styles, and all theme, animation, and dynamic styles end up running on your main thread, oftentimes re-reconciling a large percents of the React tree, and causing laggy behavior in areas that most contribute to UX.

### How Tamagui Helps

The Tamagui compiler makes writing Universal Apps much faster - especially on the web - through its optimizing compiler. It reduces bundle size, improves runtime performance, and outputs code that targets native primitives instead of running in JS (on the web, that's CSS media queries, CSS variables, and CSS pseudo styles).

It optimizes:

- Any usage of the `styled` factory function into atomic CSS.
- Most inline styles using both `partial evaluation` and `hoisting`.
- Tree depth, by turning your custom components into `div` or `View` when possible.
- The included hooks `useMedia` and `useTheme`, turning even logical conditionals into static media queries or CSS variables.

A short demo:

<TamaguiExamplesCode />

See [more examples on the homepage](/).

Notice that the compiler turned the `Text` into a `p`, and the `YStack` into a `div` (on native, this would be `Text` and `View`). This is known as tree-flattening, and for both web and native it yields very nice improvements to render performance.

This is a typical performance improvement, where much of the gains come from flattening:

<YStack my="$2">
  <BenchmarkChartWeb />
</YStack>

Across a few apps, we've seen 30-50% of components typically flatten, with a higher percent achievable just by being aware of how the flattening optimizes (adding the `// debug` comment to the top of the file will show a fuller output).

Meanwhile, on Native, because we can't optimize to anything beyond vanilla React Native code, the gains are less. Still, the results are impressive given you now have performance within 5% of hand-optimizing React Native code, except you get a whole suite of features for free.

<YStack my="$2">
  <BenchmarkChartNative />
</YStack>

You can see [more Benchmarks with explanations here](/docs/intro/benchmarks).

The compiler itself deserves more detail, which we'll expand on in the blog. For now, this serves as a decent introduction.

Compilers can dramatically improve code sharing without the typical sacrifice of performance. They don't solve every problem of universal apps, but by making responsive styling, themes and interactive styles all perform at native levels, they unlock sharing a much larger percentage of the components located in the middle to bottom of the render tree in apps.

It gives us a new choice:

<Table my="$8">
  <TableCol>
    <TableCell head></TableCell>
    <TableCell>4</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Strategy</TableCell>
    <TableCell>Universal + Compiler</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Native + Web</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Code Sharing</TableCell>
    <TableCell>~60-90%</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Ship Fast</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
  <TableCol>
    <TableCell head>Feels native</TableCell>
    <TableCell>✅</TableCell>
  </TableCol>
</Table>

Give Tamagui a try with `npm create tamagui-app`.
